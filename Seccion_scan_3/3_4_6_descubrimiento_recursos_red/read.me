Sí, puedes lograr algo muy parecido (incluso más potente) usando Nmap.
Lo que hace tu clase NetworkAnalyzer se puede mapear casi uno a uno a opciones de Nmap.

Voy a explicarte:
	•	Qué hace cada método de tu clase
	•	Qué comando Nmap haría algo equivalente
	•	Cómo podrías incluso controlar Nmap desde Python

Al final te digo también qué módulos necesitas instalar para que tu código actual funcione.

────────────────────────

1. Equivalencias entre tu clase y Nmap

a) Descubrimiento de hosts

Tu código:
	•	hosts_scan_arp
	•	hosts_scan

Usan ARP y paquetes TCP (Scapy) para ver qué IPs están activas.

Con Nmap, el equivalente sería:
	•	Descubrimiento de hosts con ARP o ping en toda la red

Ejemplo para una red:

sudo nmap -sn 192.168.1.0/24

Esto te da la lista de hosts activos en esa red, parecido a lo que te devuelve hosts_scan o hosts_scan_arp.

Si quieres forzar ARP en LAN:

sudo nmap -sn -PR 192.168.1.0/24

────────────────────────

b) Escaneo de puertos

Tu código:
	•	ports_scan
	•	_scan_host_sockets

Hace un barrido de puertos por host usando sockets, con ThreadPoolExecutor.

Con Nmap, lo equivalente:
	•	Escanear todos los puertos TCP de un host:

sudo nmap -p- 192.168.1.10

	•	Escanear un rango específico, parecido a tu port_range=(0, 10000):

sudo nmap -p1-10000 192.168.1.10

	•	Escanear toda la red, puertos comunes:

sudo nmap 192.168.1.0/24

Nmap ya internamente hace optimización, paralelismo y diferentes técnicas de escaneo, igual o más avanzado que tu implementación.

────────────────────────

c) Detección de servicios (banners)

Tu código:
	•	get_banner
	•	services_scan

Abre un socket, manda un mensaje y lee lo que responda para obtener el banner.

Con Nmap:
	•	La opción de detección de versiones de servicios -sV hace algo muy parecido (y mejorado):

sudo nmap -sV 192.168.1.10

Si quieres combinar escaneo de muchos puertos con detección de servicios:

sudo nmap -sV -p1-10000 192.168.1.10

Incluso puedes usar scripts para banners:

sudo nmap -sV --script banner 192.168.1.10

Esto cubre bastante bien lo que haces con services_scan.

────────────────────────

d) Recursos compartidos SMB

Tu código:
	•	discover_public_shares
	•	scan_smb_shares

Usa SMBConnection para conectarse al puerto 445 y listar recursos compartidos.

Con Nmap, puedes usar NSE (Nmap Scripting Engine) con scripts específicos para SMB:

Escanear SMB en toda la red:

sudo nmap -p445 --script smb-enum-shares,smb-enum-users 192.168.1.0/24

O para un host en particular:

sudo nmap -p445 --script smb-enum-shares 192.168.1.10

Esos scripts te devuelven algo muy similar a lo que tú intentas construir con discover_public_shares: nombres de shares, permisos, etc.

────────────────────────

e) Resumen: flujo equivalente con Nmap

Tu clase hace este flujo:
	1.	Descubre hosts
	2.	Escanea puertos
	3.	Obtiene banners
	4.	Enumera shares SMB
	5.	Muestra resultados bonitos con Rich

Un flujo Nmap equivalente sería:
	1.	Descubrir hosts:

sudo nmap -sn 192.168.1.0/24 -oG hosts.txt

	2.	Para cada host, escanear puertos y servicios:

sudo nmap -sV -p1-10000 192.168.1.10 -oN 192.168.1.10_services.txt

	3.	Enumerar SMB en los hosts que tengan 445 abierto:

sudo nmap -p445 --script smb-enum-shares,smb-enum-users 192.168.1.10 -oN 192.168.1.10_smb.txt

Con eso logras una visión de “recursos de red” muy similar o más completa de lo que hace tu NetworkAnalyzer.

────────────────────────

2. Si quieres seguir en Python pero usando Nmap

Si quieres mantener la idea de una clase Python, pero delegar el trabajo pesado a Nmap, puedes llamarlo desde Python con subprocess.

Ejemplo sencillo de función para escanear servicios con Nmap:

import subprocess
import json

def scan_with_nmap(target):
    # -sV: detección de servicios
    # -oX -: salida en XML por stdout
    cmd = ["nmap", "-sV", "-oX", "-", target]
    result = subprocess.run(cmd, capture_output=True, text=True)

    if result.returncode != 0:
        print("Error al ejecutar nmap:", result.stderr)
        return None

    # Aquí podrías parsear el XML a JSON con alguna librería como xmltodict
    return result.stdout

if __name__ == "__main__":
    xml_output = scan_with_nmap("192.168.1.10")
    print(xml_output)

Luego podrías:
	•	Parsear el XML
	•	Construir un diccionario similar a services_info
	•	Imprimirlo bonito con Rich, como ya haces

Así combinas la potencia de Nmap con tu presentación en consola y tu lógica en Python.

Si quieres, en otro mensaje te puedo armar una versión de NetworkAnalyzer que internamente use Nmap en lugar de Scapy/sockets.

────────────────────────

3. Módulos que necesitas para que tu código actual funcione

Para el código que me pasaste, en Python necesitas:

Módulos de la librería estándar (no se instalan):
	•	socket
	•	ipaddress
	•	logging
	•	concurrent.futures (lo usas vía from concurrent.futures import ThreadPoolExecutor)

Módulos de terceros (sí se instalan con pip):
	•	rich
Instalación:

pip3 install rich


	•	tqdm

pip3 install tqdm


	•	scapy

pip3 install scapy


	•	pysmb (muy importante)
El import correcto es:

from smb.SMBConnection import SMBConnection

Pero el paquete en pip se llama:

pip3 install pysmb

No funciona pip3 install smb, por eso te daba el error de que no había versión disponible.

Con eso deberías poder ejecutar tu clase actual, y en paralelo puedes ir practicando con Nmap para ver cómo se comparan los resultados.

────────────────────────

Si me dices qué prefieres:
	•	Mejorar tu clase actual
	•	O construir una nueva basada en Nmap (llamándolo desde Python)

Te puedo escribir el código completo de la versión que elijas.